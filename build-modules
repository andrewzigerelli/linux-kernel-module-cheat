#!/usr/bin/env python3

import distutils.dir_util
import os
import platform
import shutil

import common

class ModulesComponent(common.Component):
    def add_parser_arguments(self, parser):
        parser.add_argument(
            '--make-args',
            default='',
        )
        parser.add_argument(
            '--host',
            action='store_true',
            default=False,
            help='''\
Build the Linux kernel modules for the host instead of guest.
Use the host packaged cross toolchain.
''',
        )
        parser.add_argument(
            'kernel_modules',
            default=[],
            help='Which kernel modules to build. Default: build all',
            metavar='kernel-modules',
            nargs='*',
        )

    def do_build(self, args):
        build_dir = self.get_build_dir(args)
        os.makedirs(build_dir, exist_ok=True)
        # I kid you not, out-of-tree build is not possible, O= does not work as for the kernel build:
        #
        # * https://stackoverflow.com/questions/5718899/building-an-out-of-tree-linux-kernel-module-in-a-separate-object-directory
        # * https://stackoverflow.com/questions/12244979/build-kernel-module-into-a-specific-directory
        # * https://stackoverflow.com/questions/18386182/out-of-tree-kernel-modules-multiple-module-single-makefile-same-source-file
        #
        # This copies only modified files as per:
        # https://stackoverflow.com/questions/5718899/building-an-out-of-tree-linux-kernel-module-in-a-separate-object-directory
        distutils.dir_util.copy_tree(
            kwargs['kernel_modules_src_dir'],
            os.path.join(build_dir, kwargs['kernel_modules_subdir']),
            update=1,
        )
        distutils.dir_util.copy_tree(
            kwargs['include_src_dir'],
            os.path.join(build_dir, kwargs['include_subdir']),
            update=1,
        )
        all_kernel_modules = []
        for basename in os.listdir(kwargs['kernel_modules_src_dir']):
            src = os.path.join(kwargs['kernel_modules_src_dir'], basename)
            if os.path.isfile(src):
                noext, ext = os.path.splitext(basename)
                if ext == kwargs['c_ext']:
                    all_kernel_modules.append(noext)
        if kwargs['kernel_modules'] == []:
            kernel_modules = all_kernel_modules
        else:
            kernel_modules = map(lambda x: os.path.splitext(os.path.split(x)[1])[0], kwargs['kernel_modules'])
        object_files = map(lambda x: x + kwargs['obj_ext'], kernel_modules)
        tool = 'gcc'
        if kwargs['host']:
            allowed_toolchains = ['host']
            build_subdir = kwargs['kernel_modules_build_host_subdir']
        else:
            allowed_toolchains = None
            build_subdir = kwargs['kernel_modules_build_subdir']
        gcc = common.get_toolchain_tool(tool, allowed_toolchains=allowed_toolchains)
        prefix = gcc[:-len(tool)]
        ccache = shutil.which('ccache')
        if ccache is not None:
            cc = '{} {}'.format(ccache, gcc)
        else:
            cc = gcc
        if kwargs['verbose']:
            verbose = ['V=1']
        else:
            verbose = []
        if kwargs['host']:
            linux_dir = os.path.join('/lib', 'modules', platform.uname().release, 'build')
        else:
            linux_dir = kwargs['linux_build_dir']
        self.sh.run_cmd(
            (
                [
                    'make', LF,
                    '-j', str(kwargs['nproc']), LF,
                    'ARCH={}'.format(kwargs['linux_arch']), LF,
                    'CC={}'.format(cc), LF,
                    'CROSS_COMPILE={}'.format(prefix), LF,
                    'LINUX_DIR={}'.format(linux_dir), LF,
                    'M={}'.format(build_subdir), LF,
                    'OBJECT_FILES={}'.format(' '.join(object_files)), LF,
                ] +
                common.shlex_split(kwargs['make_args']) +
                verbose
            ),
            cwd=os.path.join(kwargs['kernel_modules_build_subdir']),
        )
        if not kwargs['host']:
            common.copy_dir_if_update_non_recursive(
                srcdir=kwargs['kernel_modules_build_subdir'],
                destdir=kwargs['out_rootfs_overlay_dir'],
                filter_ext=kwargs['kernel_module_ext'],
            )

    def get_argparse_args(self):
        return {
                'description': '''\
Build our Linux kernel modules without using Buildroot.

See also: https://github.com/cirosantilli/linux-kernel-module-cheat#host
'''
        }

    def get_build_dir(self, args):
        if kwargs['host']:
            return os.path.join(kwargs['kernel_modules_build_host_dir'])
        else:
            return os.path.join(kwargs['kernel_modules_build_dir'])

if __name__ == '__main__':
    ModulesComponent().build()
