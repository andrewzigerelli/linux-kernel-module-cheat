#!/usr/bin/env python3

import os

import common

class M5Component(common.Component):
    def get_make_cmd(self, args):
        allowed_toolchains = ['buildroot']
        cc = common.get_toolchain_tool('gcc', allowed_toolchains=allowed_toolchains)
        ld = common.get_toolchain_tool('ld', allowed_toolchains=allowed_toolchains)
        if kwargs['arch'] == 'x86_64':
            arch = 'x86'
        else:
            arch = kwargs['arch']
        return [
            'make', LF,
            '-j', str(kwargs['nproc']), LF,
            '-f', 'Makefile.{}'.format(arch), LF,
            'CC={}'.format(cc), LF,
            'LD={}'.format(ld), LF,
            'PWD={}'.format(kwargs['gem5_m5_source_dir']), LF,
        ]

    def do_build(self, args):
        os.makedirs(kwargs['gem5_m5_build_dir'], exist_ok=True)
        # We must clean first or else the build outputs of one arch can conflict with the other.
        # I should stop being lazy and go actually patch gem5 to support out of tree m5 build...
        self.clean(args)
        self.sh.run_cmd(
            self.get_make_cmd(args),
            cwd=kwargs['gem5_m5_source_dir'],
        )
        os.makedirs(kwargs['out_rootfs_overlay_bin_dir'], exist_ok=True)
        self.sh.cp(os.path.join(kwargs['gem5_m5_source_dir'], 'm5'), kwargs['out_rootfs_overlay_bin_dir'])

    def clean(self, args):
        self.sh.run_cmd(
            self.get_make_cmd(args) + ['clean', LF],
            cwd=kwargs['gem5_m5_source_dir'],
        )

if __name__ == '__main__':
    M5Component().build()
