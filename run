#!/usr/bin/env python3

import os
import re
import shutil
import subprocess
import sys
import time

import common

defaults = {
    'background': False,
    'cpus': 1,
    'wait_gdb': False,
    'debug_vm': None,
    'eval': None,
    'extra_emulator_args': [],
    'gem5_exe_args': '',
    'gem5_script': 'fs',
    'gem5_readfile': '',
    'gem5_restore': None,
    'graphic': False,
    'kernel_cli': None,
    'kernel_cli_after_dash': None,
    'eval_after': None,
    'kgdb': False,
    'kdb': False,
    'kvm': False,
    'memory': '256M',
    'record': False,
    'replay': False,
    'terminal': False,
    'tmux': None,
    'trace': None,
    'trace_stdout': False,
    'userland': None,
    'userland_before': '',
    'vnc': False,
}

def main(args, extra_args=None):
    global defaults
    args = common.resolve_args(defaults, args, extra_args)
    # Common qemu / gem5 logic.
    # nokaslr:
    # * https://unix.stackexchange.com/questions/397939/turning-off-kaslr-to-debug-linux-kernel-using-qemu-and-gdb
    # * https://stackoverflow.com/questions/44612822/unable-to-debug-kernel-with-qemu-gdb/49840927#49840927
    #   Turned on by default since v4.12
    kernel_cli = 'console_msg_format=syslog nokaslr norandmaps panic=-1 printk.devkmsg=on printk.time=y rw'
    if kwargs['kernel_cli'] is not None:
        kernel_cli += ' {}'.format(kwargs['kernel_cli'])
    kernel_cli_after_dash = ''
    extra_emulator_args = []
    extra_qemu_args = []
    if kwargs['debug_vm'] is not None:
        debug_vm = ['gdb', LF, '-q', common.Newline] + common.shlex_split(kwargs['debug_vm']) + ['--args', common.Newline]
    else:
        debug_vm = []
    if kwargs['wait_gdb']:
        extra_qemu_args.extend(['-S', LF])
    if kwargs['eval_after'] is not None:
        kernel_cli_after_dash += ' lkmc_eval_base64="{}"'.format(common.base64_encode(kwargs['eval_after']))
    if kwargs['kernel_cli_after_dash'] is not None:
        kernel_cli_after_dash += ' {}'.format(kwargs['kernel_cli_after_dash'])
    if kwargs['vnc']:
        vnc = ['-vnc', ':0', LF]
    else:
        vnc = []
    if kwargs['initrd'] or kwargs['initramfs']:
        ramfs = True
    else:
        ramfs = False
    if kwargs['eval'] is not None:
        if ramfs:
            initarg = 'rdinit'
        else:
            initarg = 'init'
        kernel_cli += ' {}=/eval_base64.sh'.format(initarg)
        kernel_cli_after_dash += ' lkmc_eval="{}"'.format(common.base64_encode(kwargs['eval']))
    if not kwargs['graphic']:
        extra_qemu_args.extend(['-nographic', LF])
    console = None
    console_type = None
    console_count = 0
    if kwargs['arch'] == 'x86_64':
        console_type = 'ttyS'
    elif kwargs['is_arm']:
        console_type = 'ttyAMA'
    console = '{}{}'.format(console_type, console_count)
    console_count += 1
    if not (kwargs['arch'] == 'x86_64' and kwargs['graphic']):
        kernel_cli += ' console={}'.format(console)
    extra_console = '{}{}'.format(console_type, console_count)
    console_count += 1
    if kwargs['kdb'] or kwargs['kgdb']:
        kernel_cli += ' kgdbwait'
        if kwargs['kdb']:
            if kwargs['graphic']:
                kdb_cmd = 'kbd,'
            else:
                kdb_cmd = ''
            kernel_cli += ' kgdboc={}{},115200'.format(kdb_cmd, console)
        if kwargs['kgdb']:
            kernel_cli += ' kgdboc={},115200'.format(extra_console)
    if kernel_cli_after_dash:
        kernel_cli += " -{}".format(kernel_cli_after_dash)
    extra_env = {}
    if kwargs['trace'] is None:
        do_trace = False
        # A dummy value that is already turned on by default and does not produce large output,
        # just to prevent QEMU from emitting a warning that '' is not valid.
        trace_type = 'load_file'
    else:
        do_trace = True
        trace_type = kwargs['trace']

    def raise_rootfs_not_found():
        if not kwargs['dry_run']:
            raise Exception('Root filesystem not found. Did you build it?\n' \
                            'Tried to use: ' + kwargs['disk_image'])
    def raise_image_not_found():
        if not kwargs['dry_run']:
            raise Exception('Executable image not found. Did you build it?\n' \
                            'Tried to use: ' + kwargs['image'])
    if kwargs['image'] is None:
        raise Exception('Baremetal ELF file not found. Tried:\n' + '\n'.join(paths))
    cmd = debug_vm.copy()
    if kwargs['emulator'] == 'gem5':
        if kwargs['baremetal'] is None:
            if not os.path.exists(kwargs['rootfs_raw_file']):
                if not os.path.exists(kwargs['qcow2_file']):
                    raise_rootfs_not_found()
                common.raw_to_qcow2(prebuilt=kwargs['prebuilt'], reverse=True)
        else:
            if not os.path.exists(kwargs['gem5_fake_iso']):
                os.makedirs(os.path.dirname(kwargs['gem5_fake_iso']), exist_ok=True)
                common.write_string_to_file(kwargs['gem5_fake_iso'], 'a' * 512)
        if not os.path.exists(kwargs['image']):
            # This is to run gem5 from a prebuilt download.
            if (not kwargs['baremetal'] is None) or (not os.path.exists(kwargs['linux_image'])):
                raise_image_not_found()
            self.sh.run_cmd([os.path.join(kwargs['extract_vmlinux'], kwargs['linux_image'])])
        os.makedirs(os.path.dirname(kwargs['gem5_readfile']), exist_ok=True)
        common.write_string_to_file(kwargs['gem5_readfile'], kwargs['gem5_readfile'])
        memory = '{}B'.format(kwargs['memory'])
        gem5_exe_args = common.shlex_split(kwargs['gem5_exe_args'])
        if do_trace:
            gem5_exe_args.extend(['--debug-flags={}'.format(trace_type), LF])
        extra_env['M5_PATH'] = kwargs['gem5_system_dir']
        # https://stackoverflow.com/questions/52312070/how-to-modify-a-file-under-src-python-and-run-it-without-rebuilding-in-gem5/52312071#52312071
        extra_env['M5_OVERRIDE_PY_SOURCE'] = 'true'
        if kwargs['trace_stdout']:
            debug_file = 'cout'
        else:
            debug_file = 'trace.txt'
        cmd.extend(
            [
                kwargs['executable'], LF,
                '--debug-file', debug_file, LF,
                '--listener-mode', 'on', LF,
                '--outdir', kwargs['m5out_dir'], LF,
            ] +
            gem5_exe_args
        )
        if kwargs['userland'] is not None:
            cmd.extend([
                kwargs['gem5_se_file'], LF,
                '-c', common.resolve_userland(kwargs['userland']), LF,
            ])
        else:
            if kwargs['gem5_script'] == 'fs':
                # TODO port
                if kwargs['gem5_restore'] is not None:
                    cpt_dirs = common.gem_list_checkpoint_dirs()
                    cpt_dir = cpt_dirs[-kwargs['gem5_restore']]
                    extra_emulator_args.extend(['-r', str(sorted(cpt_dirs).index(cpt_dir) + 1)])
                cmd.extend([
                    kwargs['gem5_fs_file'], LF,
                    '--disk-image', kwargs['disk_image'], LF,
                    '--kernel', kwargs['image'], LF,
                    '--mem-size', memory, LF,
                    '--num-cpus', str(kwargs['cpus']), LF,
                    '--script', kwargs['gem5_readfile'], LF,
                ])
                if kwargs['arch'] == 'x86_64':
                    if kwargs['kvm']:
                        cmd.extend(['--cpu-type', 'X86KvmCPU', LF])
                    cmd.extend(['--command-line', 'earlyprintk={} lpj=7999923 root=/dev/sda {}'.format(console, kernel_cli), LF])
                elif kwargs['is_arm']:
                    if kwargs['kvm']:
                        cmd.extend(['--cpu-type', 'ArmV8KvmCPU', LF])
                    cmd.extend([
                        # TODO why is it mandatory to pass mem= here? Not true for QEMU.
                        # Anything smaller than physical blows up as expected, but why can't it auto-detect the right value?
                        '--command-line', 'earlyprintk=pl011,0x1c090000 lpj=19988480 rw loglevel=8 mem={} root=/dev/sda {}'.format(memory, kernel_cli), LF,
                        '--dtb-filename', os.path.join(kwargs['gem5_system_dir'], 'arm', 'dt', 'armv{}_gem5_v1_{}cpu.dtb'.format(kwargs['armv'], kwargs['cpus'])), LF,
                        '--machine-type', kwargs['machine'], LF,
                    ])
                    if kwargs['baremetal'] is None:
                        cmd.extend([
                            '--param', 'system.panic_on_panic = True', LF])
                    else:
                        cmd.extend([
                            '--bare-metal', LF,
                            '--param', 'system.auto_reset_addr = True', LF,
                        ])
                        if kwargs['arch'] == 'aarch64':
                            # https://stackoverflow.com/questions/43682311/uart-communication-in-gem5-with-arm-bare-metal/50983650#50983650
                            cmd.extend(['--param', 'system.highest_el_is_64 = True', LF])
            elif kwargs['gem5_script'] == 'biglittle':
                if kwargs['kvm']:
                    cpu_type = 'kvm'
                else:
                    cpu_type = 'atomic'
                if kwargs['gem5_restore'] is not None:
                    cpt_dir = common.gem_list_checkpoint_dirs()[-kwargs['gem5_restore']]
                    extra_emulator_args.extend(['--restore-from', os.path.join(kwargs['m5out_dir'], cpt_dir)])
                cmd.extend([
                    os.path.join(kwargs['gem5_source_dir'], 'configs', 'example', 'arm', 'fs_bigLITTLE.py'), LF,
                    '--big-cpus', '2', LF,
                    '--cpu-type', cpu_type, LF,
                    '--disk', kwargs['disk_image'], LF,
                    '--dtb', os.path.join(kwargs['gem5_system_dir'], 'arm', 'dt', 'armv8_gem5_v1_big_little_2_2.dtb'), LF,
                    '--kernel', kwargs['image'], LF,
                    '--little-cpus', '2', LF,
                ])
        if kwargs['wait_gdb']:
            # https://stackoverflow.com/questions/49296092/how-to-make-gem5-wait-for-gdb-to-connect-to-reliably-break-at-start-kernel-of-th
            cmd.extend(['--param', 'system.cpu[0].wait_for_remote_gdb = True', LF])
    else:
        qemu_user_and_system_options = [
            '-trace', 'enable={},file={}'.format(trace_type, kwargs['qemu_trace_file']), LF,
        ]
        if kwargs['userland'] is not None:
            if kwargs['wait_gdb']:
                debug_args = ['-g', str(kwargs['gdb_port']), LF]
            else:
                debug_args = []
            cmd.extend(
                [
                    os.path.join(kwargs['qemu_build_dir'], '{}-linux-user'.format(kwargs['arch']), 'qemu-{}'.format(kwargs['arch'])), LF,
                    '-L', kwargs['target_dir'], LF
                ] +
                qemu_user_and_system_options +
                common.shlex_split(kwargs['userland_before']) +
                debug_args +
                [
                    common.resolve_userland(kwargs['userland']), LF
                ]
            )
        else:
            if not os.path.exists(kwargs['image']):
                raise_image_not_found()
            extra_emulator_args.extend(extra_qemu_args)
            common.make_run_dirs()
            if kwargs['prebuilt'] or not os.path.exists(kwargs['qemu_executable']):
                qemu_executable = kwargs['qemu_executable_basename']
                qemu_executable_prebuilt = True
            else:
                qemu_executable = kwargs['qemu_executable']
                qemu_executable_prebuilt = False
            qemu_executable = shutil.which(qemu_executable)
            if qemu_executable is None:
                raise Exception('QEMU executable not found, did you forget to build or install it?\n' \
                                'Tried to use: ' + qemu_executable)
            if kwargs['debug_vm']:
                serial_monitor = []
            else:
                if kwargs['background']:
                    serial_monitor = ['-serial', 'file:{}'.format(kwargs['qemu_background_serial_file']), LF]
                else:
                    serial_monitor = ['-serial', 'mon:stdio', LF]
            if kwargs['kvm']:
                extra_emulator_args.extend(['-enable-kvm', LF])
            extra_emulator_args.extend(['-serial', 'tcp::{},server,nowait'.format(kwargs['extra_serial_port']), LF])
            virtfs_data = [
                (kwargs['p9_dir'], 'host_data'),
                (kwargs['out_dir'], 'host_out'),
                (kwargs['out_rootfs_overlay_dir'], 'host_out_rootfs_overlay'),
                (kwargs['rootfs_overlay_dir'], 'host_rootfs_overlay'),
            ]
            virtfs_cmd = []
            for virtfs_dir, virtfs_tag in virtfs_data:
                if os.path.exists(virtfs_dir):
                    virtfs_cmd.extend([
                        '-virtfs',
                        'local,path={virtfs_dir},mount_tag={virtfs_tag},security_model=mapped,id={virtfs_tag}' \
                            .format(virtfs_dir=virtfs_dir, virtfs_tag=virtfs_tag),
                        LF,
                    ])
            cmd.extend(
                [
                    qemu_executable, LF,
                    '-device', 'rtl8139,netdev=net0', LF,
                    '-gdb', 'tcp::{}'.format(kwargs['gdb_port']), LF,
                    '-kernel', kwargs['image'], LF,
                    '-m', kwargs['memory'], LF,
                    '-monitor', 'telnet::{},server,nowait'.format(kwargs['qemu_monitor_port']), LF,
                    '-netdev', 'user,hostfwd=tcp::{}-:{},hostfwd=tcp::{}-:22,id=net0'.format(kwargs['qemu_hostfwd_generic_port'], kwargs['qemu_hostfwd_generic_port'], kwargs['qemu_hostfwd_ssh_port']), LF,
                    '-no-reboot', LF,
                    '-smp', str(kwargs['cpus']), LF,
                ] +
                virtfs_cmd +
                serial_monitor +
                vnc
            )
            if not qemu_executable_prebuilt:
                cmd.extend(qemu_user_and_system_options)
            if kwargs['initrd']:
                extra_emulator_args.extend(['-initrd', os.path.join(kwargs['buildroot_images_dir'], 'rootfs.cpio')])
            rr = kwargs['record'] or kwargs['replay']
            if ramfs:
                # TODO why is this needed, and why any string works.
                root = 'root=/dev/anything'
            else:
                if rr:
                    driveif = 'none'
                    rrid = ',id=img-direct'
                    root = 'root=/dev/sda'
                    snapshot = ''
                else:
                    driveif = 'virtio'
                    root = 'root=/dev/vda'
                    rrid = ''
                    snapshot = ',snapshot'
                if kwargs['baremetal'] is None:
                    if not os.path.exists(kwargs['qcow2_file']):
                        if not os.path.exists(kwargs['rootfs_raw_file']):
                            raise_rootfs_not_found()
                        common.raw_to_qcow2(prebuilt=kwargs['prebuilt'])
                    extra_emulator_args.extend([
                        '-drive',
                        'file={},format=qcow2,if={}{}{}'.format(kwargs['disk_image'], driveif, snapshot, rrid),
                        LF,
                    ])
                    if rr:
                        extra_emulator_args.extend([
                        '-drive', 'driver=blkreplay,if=none,image=img-direct,id=img-blkreplay', LF,
                        '-device', 'ide-hd,drive=img-blkreplay', LF,
                    ])
            if rr:
                extra_emulator_args.extend([
                    '-object', 'filter-replay,id=replay,netdev=net0',
                    '-icount', 'shift=7,rr={},rrfile={}'.format('record' if kwargs['record'] else 'replay', kwargs['qemu_rrfile']),
                ])
                virtio_gpu_pci = []
            else:
                virtio_gpu_pci = ['-device', 'virtio-gpu-pci', LF]
            if kwargs['arch'] == 'x86_64':
                append = ['-append', '{} nopat {}'.format(root, kernel_cli), LF]
                cmd.extend([
                    '-M', kwargs['machine'], LF,
                    '-device', 'edu', LF,
                ])
            elif kwargs['is_arm']:
                extra_emulator_args.extend(['-semihosting', LF])
                if kwargs['arch'] == 'arm':
                    cpu = 'cortex-a15'
                else:
                    cpu = 'cortex-a57'
                append = ['-append', '{} {}'.format(root, kernel_cli), LF]
                cmd.extend(
                    [
                        # highmem=off needed since v3.0.0 due to:
                        # http://lists.nongnu.org/archive/html/qemu-discuss/2018-08/msg00034.html
                        '-M', '{},highmem=off'.format(kwargs['machine']), LF,
                        '-cpu', cpu, LF,
                    ] +
                    virtio_gpu_pci
                )
            if kwargs['baremetal'] is None:
                cmd.extend(append)
    if kwargs['tmux'] is not None:
        tmux_args = '--run-id {}'.format(kwargs['run_id'])
        if kwargs['emulator'] == 'gem5':
            tmux_cmd = './gem5-shell'
        elif kwargs['wait_gdb']:
            tmux_cmd = './run-gdb'
            # TODO find a nicer way to forward all those args automatically.
            # Part of me wants to: https://github.com/jonathanslenders/pymux
            # but it cannot be used as a library properly it seems, and it is
            # slower than tmux.
            tmux_args += " --arch {} --linux-build-id '{}' --run-id '{}'".format(
                kwargs['arch'],
                kwargs['linux_build_id'],
                kwargs['run_id'],
            )
            if kwargs['baremetal']:
                tmux_args += " --baremetal '{}'".format(kwargs['baremetal'])
            if kwargs['userland']:
                tmux_args += " --userland '{}'".format(kwargs['userland'])
        tmux_args += ' {}'.format(kwargs['tmux'])
        subprocess.Popen([
            os.path.join(kwargs['root_dir'], 'tmu'),
            "sleep 2;{} {}".format(tmux_cmd, tmux_args)
        ])
    cmd.extend(extra_emulator_args)
    cmd.extend(kwargs['extra_emulator_args'])
    if debug_vm or kwargs['terminal']:
        out_file = None
    else:
        out_file = kwargs['termout_file']
    self.sh.run_cmd(cmd, cmd_file=kwargs['run_cmd_file'], out_file=out_file, extra_env=extra_env)
    # Check if guest panicked.
    if kwargs['emulator'] == 'gem5':
        # We have to do some parsing here because gem5 exits with status 0 even when panic happens.
        # Grepping for '^panic: ' does not work because some errors don't show that message.
        panic_msg = b'--- BEGIN LIBC BACKTRACE ---$'
    else:
        panic_msg = b'Kernel panic - not syncing'
    panic_re = re.compile(panic_msg)
    error_string_found = False
    if out_file is not None and not kwargs['dry_run']:
        with open(kwargs['termout_file'], 'br') as logfile:
            for line in logfile:
                if panic_re.search(line):
                    error_string_found = True
        if os.path.exists(kwargs['guest_terminal_file']):
            with open(kwargs['guest_terminal_file'], 'br') as logfile:
                lines = logfile.readlines()
                if lines:
                    last_line = lines[-1]
                    if last_line.rstrip() == kwargs['magic_fail_string']:
                        error_string_found = True
        if error_string_found:
            common.log_error('simulation error detected by parsing logs')
            return 1
    return 0

def get_argparse():
    parser = common.get_argparse(argparse_args={'description':'Run Linux on an emulator'})
    init_group = parser.add_mutually_exclusive_group()
    kvm_group = parser.add_mutually_exclusive_group()
    parser.add_argument(
        '--background', default=defaults['background'], action='store_true',
        help='''\
Send QEMU output to a file instead of the terminal so it does not require a
terminal attached to run on the background. Interactive input cannot be given.
TODO: use a port instead. If only there was a way to redirect a serial to multiple
places, both to a port and a file? We use the file currently to be able to have
any output at all.
https://superuser.com/questions/1373226/how-to-redirect-qemu-serial-output-to-both-a-file-and-the-terminal-or-a-port
'''
    )
    parser.add_argument(
        '-c', '--cpus', default=defaults['cpus'], type=int,
        help='Number of guest CPUs to emulate. Default: %(default)s'
    )
    parser.add_argument(
        '-D', '--debug-vm', default=defaults['debug_vm'], nargs='?', action='store', const='',
        help='Run GDB on the emulator itself.'
    )
    parser.add_argument(
        '-E', '--eval',
        help='''\
Replace the normal init with a minimal init that just evals the given string.
See: https://github.com/cirosantilli/linux-kernel-module-cheat#replace-init
'''
    )
    parser.add_argument(
        '-e', '--kernel-cli',
        help='''\
Pass an extra Linux kernel command line options, and place them before
the dash separator `-`. Only options that come before the `-`, i.e.
"standard" options, should be passed with this option.
Example: `./run -a arm -e 'init=/poweroff.out'`
'''
    )
    parser.add_argument(
        '-F', '--eval-after',
        help='''\
Pass a base64 encoded command line parameter that gets evalled at the end of
the normal init.
See: https://github.com/cirosantilli/linux-kernel-module-cheat#init-busybox
'''
    )
    parser.add_argument(
        '-f', '--kernel-cli-after-dash',
        help='''\
Pass an extra Linux kernel command line options, add a dash `-`
separator, and place the options after the dash. Intended for custom
options understood by our `init` scripts, most of which are prefixed
by `lkmc_`.
Example: `./run --kernel-cli-after-dash 'lkmc_eval="wget google.com" lkmc_lala=y'`
Mnenomic: `-f` comes after `-e`.
'''
    )
    parser.add_argument(
        '-G', '--gem5-exe-args', default=defaults['gem5_exe_args'],
        help='''\
Pass extra options to the gem5 executable.
Do not confuse with the arguments passed to config scripts,
like `fs.py`. Example:
./run -G '--debug-flags=Exec --debug' --gem5 -- --cpu-type=HPI --caches
will run:
gem.op5 --debug-flags=Exec fs.py --cpu-type=HPI --caches
'''
    )
    parser.add_argument(
        '--gem5-script', default=defaults['gem5_script'], choices=['fs', 'biglittle'],
        help='Which gem5 script to use'
    )
    parser.add_argument(
        '--gem5-readfile', default=defaults['gem5_readfile'],
        help='Set the contents of m5 readfile to this string.'
    )
    kvm_group.add_argument(
        '-K', '--kvm', default=defaults['kvm'], action='store_true',
        help='Use KVM. Only works if guest arch == host arch'
    )
    parser.add_argument(
        '--kgdb', default=defaults['kgdb'], action='store_true'
    )
    parser.add_argument(
        '--kdb', default=defaults['kdb'], action='store_true'
    )
    parser.add_argument(
        '-l', '--gem5-restore', type=int,
        help='''\
Restore the nth most recently taken gem5 checkpoint according to directory
timestamps.
'''
    )
    parser.add_argument(
        '-m', '--memory', default=defaults['memory'],
        help='''\
Set the memory size of the guest. E.g.: `-m 512M`. We try to keep the default
at the minimal ammount amount that boots all archs. Anything lower could lead
some arch to fail to boot.
Default: %(default)s
'''
    )
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        '-R', '--replay', default=defaults['replay'], action='store_true',
        help='Replay a QEMU run record deterministically'
    )
    group.add_argument(
        '-r', '--record', default=defaults['record'], action='store_true',
        help='Record a QEMU run record for later replay with `-R`'
    )
    parser.add_argument(
        '-T', '--trace',
        help='''\
Set trace events to be enabled. If not given, gem5 tracing is completely
disabled, while QEMU tracing is enabled but uses default traces that are very
rare and don't affect performance, because `./configure
--enable-trace-backends=simple` seems to enable some traces by default, e.g.
`pr_manager_run`, and I don't know how to get rid of them.
'''
    )
    parser.add_argument(
        '--trace-stdout', default=defaults['trace_stdout'], action='store_true',
        help='''\
Output trace to stdout instead of a file. Only works for gem5 currently.
'''
    )
    init_group.add_argument(
        '--terminal', default=defaults['terminal'], action='store_true',
        help='''\
Output to the terminal, don't pipe to tee as the default.
Does not save the output to a file, but allows you to use debuggers.
Set automatically by --debug-vm, but you still need this option to debug
gem5 Python scripts.
'''
    )
    parser.add_argument(
        '-t', '--tmux', default=defaults['tmux'], nargs='?', action='store', const='',
        help='''\
Create a tmux split the window. You must already be inside of a `tmux` session
to use this option:
* on the main window, run the emulator as usual
* on the split:
** if on QEMU and `-d` is given, GDB
** if on gem5, the gem5 terminal
If values are given to this option, pass those as parameters
to the program running on the split.
'''
    )
    parser.add_argument(
        '-u', '--userland', default=defaults['userland'],
        help='''\
Run the given userland executable in user mode instead of booting the Linux kernel
in full system mode. In gem5, user mode is called Syscall Emulation (SE) mode and
uses se.py.

Path resolution is similar to --baremetal.
'''
    )
    parser.add_argument(
        '--userland-before', default=defaults['userland_before'],
        help='''\
Pass these arguments to the QEMU user mode CLI before the program to execute.
This is required with --userland since arguments that come at the end are interpreted
as command line arguments to that executable.
'''
    )
    kvm_group.add_argument(
        '-w', '--wait-gdb', default=defaults['wait_gdb'], action='store_true',
        help='Wait for GDB to connect before starting execution'
    )
    parser.add_argument(
        '-x', '--graphic', default=defaults['graphic'], action='store_true',
        help='Run in graphic mode. Mnemonic: X11'
    )
    parser.add_argument(
        '-V', '--vnc', default=defaults['vnc'], action='store_true',
        help='''\
Run QEMU with VNC instead of the default SDL. Connect to it with:
`vinagre localhost:5900`.
'''
    )
    parser.add_argument(
        'extra_emulator_args', nargs='*', default=defaults['extra_emulator_args'],
        help='Extra options to append at the end of the emulator command line'
    )
    return parser

if __name__ == '__main__':
    parser = get_argparse()
    args = common.setup(parser)
    start_time = time.time()
    exit_status = main(args)
    end_time = time.time()
    common.print_time(end_time - start_time)
    sys.exit(exit_status)
